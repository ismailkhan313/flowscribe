{"mappings":";;;;;;;;;;;;;;;UEgJY;;GAAA,8CAAA;;;;;AC7IZ,MAAM,gCAAU,CAAA,GAAA,aAAK,EAAE,yBAAyB,KAAK,CAAC,CAAA,GAAA,8BAAe;AACrE,MAAM,gCAAkB,CAAA,GAAA,aAAK,EAAE;AAIxB,MAAM,4CAAc,OAAO;IAC9B,OAAO,8BAAQ,GAAG,CAAC,MAAM,GAAG,GAAG,IAAI;AACvC;AAEO,MAAM,4CAAU,OAAO,MAAc,cAA4B,CAAC,CAAC;IACtE,OAAO,8BAAQ,GAAG,CAAC,MAAM,KAAK,CAAC,aAAa,GAAG,GAAG,IAAI;AAC1D;;;AFNA,MAAM,2CAAqB;AASpB,MAAM,4CAAY,OAAO;IAC5B,MAAM,cAAwC;YAAE;QAAI,KAAK;IAAmB;IAC5E,MAAM,QAAE,IAAI,EAAE,GAAI,MAAM,CAAA,GAAA,yCAAM,EAAE,WAAW;IAE3C,IAAI,CAAC,MACD,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,UAAU,CAAC;IAG5C,OAAO;cAAE;IAAK;AAClB;AASO,MAAM,4CAAc,OAAO;IAC9B,IAAI;QACA,MAAM,OAAQ,MAAM,CAAA,GAAA,yCAAU,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,CAAC;QAC7C,OAAO;IACX,EAAE,OAAO,KAAU;QACf,IAAI,IAAI,MAAM,KAAK,KACf,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,UAAU,CAAC;QAG1C,MAAM;IACV;AACJ;AAQO,MAAM,4CAAc,OAAO;IAC9B,MAAM,cAAsC;YAAE;QAAI,SAAS,CAAA,GAAA,yCAAO,EAAE,OAAO;QAAE,KAAK;IAAmB;IACrG,MAAM,OAAQ,MAAM,CAAA,GAAA,yCAAM,EAAE,CAAC,KAAK,CAAC,EAAE;IAErC,OAAO;AACX;AAUO,MAAM,4CAAU,OAAO,QAAgB;IAC1C,MAAM,cAAsC;QAAE,SAAS;QAAQ,IAAI;QAAY,KAAK;IAAmB;IACvG,MAAM,QAAE,IAAI,QAAE,IAAI,EAAE,GAAI,MAAM,CAAA,GAAA,yCAAM,EAAE,SAAS;IAE/C,IAAI,CAAC,QAAQ,CAAC,MACV,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,OAAO,OAAO,EAAE,WAAW,UAAU,CAAC;IAGlE,OAAO;QAAE,MAAM,KAAK,KAAK,CAAC;cAAuB;IAAK;AAC1D;AASO,MAAM,4CAAS,OAClB,OACA,YAAE,QAAQ,aAAE,SAAS,EAAE,GAAG,SAAwB,GAAG,CAAC,CAAC;IAEvD,MAAM,cAAwC;QAC1C,GAAG,OAAO;QACV,GAAI,YAAY;YAAE,QAAQ;QAAS,CAAC;QACpC,GAAI,aAAa;YAAE,MAAM;QAAU,CAAC;QACpC,GAAG;QACH,KAAK;IACT;IACA,MAAM,SAAE,KAAK,QAAE,IAAI,EAAE,GAAI,MAAM,CAAA,GAAA,yCAAM,EAAE,WAAW;IAElD,OAAO;eAAE;QAAO,MAAM,KAAK,GAAG,CAAC,CAAC,IAAO,CAAA;gBAAE,GAAG,CAAC;gBAAE,MAAM,KAAK,KAAK,CAAC,EAAE,IAAI;YAAE,CAAA;IAAI;AAChF;;;;;;;AIrGA,gCAAgC;;;;;;;UCgBpB;;GAAA,8CAAA;;","sources":["src/index.ts","src/api.ts","src/types/api/book.ts","src/utils/network.ts","src/types/api/author.ts","src/types/api/bookFile.ts","src/types/index.ts"],"sourcesContent":["export * from './api';\nexport * from './types/api/author';\nexport * from './types/api/bookFile';\nexport * from './types/index';\n","import { PageMetadata, PageResult, SearchOptions, SearchResults } from './types';\nimport { AuthorApiQueryParameters, AuthorApiResponse } from './types/api/author';\nimport { BookApiQueryParameters, BookApiResponse, Includes } from './types/api/book';\nimport { BookFileApiResponse } from './types/api/bookFile';\nimport { PageApiQueryParameters, PageApiResponse } from './types/api/page';\nimport { SearchApiQueryParameters, SearchApiResponse } from './types/api/search';\nimport { getFileJson, getJson } from './utils/network';\n\nconst API_VERSION_NUMBER = 3;\n\n/**\n * Fetches author information by ID.\n *\n * @param id - The unique identifier of the author to retrieve.\n * @returns A promise that resolves to the author information.\n * @throws Will throw an error if the author is not found.\n */\nexport const getAuthor = async (id: number): Promise<AuthorApiResponse> => {\n    const queryParams: AuthorApiQueryParameters = { id, ver: API_VERSION_NUMBER };\n    const { info } = (await getJson('/author', queryParams)) as AuthorApiResponse;\n\n    if (!info) {\n        throw new Error(`Author ${id} not found`);\n    }\n\n    return { info };\n};\n\n/**\n * Fetches the book contents by ID.\n *\n * @param id - The unique identifier of the book to retrieve.\n * @returns A promise that resolves to the book file information.\n * @throws Will throw an error if the book file is not found.\n */\nexport const getBookFile = async (id: number): Promise<BookFileApiResponse> => {\n    try {\n        const file = (await getFileJson(`/${id}.json`)) as BookFileApiResponse;\n        return file;\n    } catch (err: any) {\n        if (err.status === 404) {\n            throw new Error(`Book ${id} not found`);\n        }\n\n        throw err;\n    }\n};\n\n/**\n * Fetches the book information by ID.\n *\n * @param id - The unique identifier of the book to retrieve.\n * @returns A promise that resolves to the book information including indexes.\n */\nexport const getBookInfo = async (id: number): Promise<BookApiResponse> => {\n    const queryParams: BookApiQueryParameters = { id, include: Includes.Indexes, ver: API_VERSION_NUMBER };\n    const book = (await getJson(`/book`, queryParams)) as BookApiResponse;\n\n    return book;\n};\n\n/**\n * Fetches a specific page from a book by book ID and page number.\n *\n * @param bookId - The unique identifier of the book.\n * @param pageNumber - The page number to retrieve.\n * @returns A promise that resolves to the page metadata and text.\n * @throws Will throw an error if the page is not found.\n */\nexport const getPage = async (bookId: number, pageNumber: number): Promise<PageResult> => {\n    const queryParams: PageApiQueryParameters = { book_id: bookId, pg: pageNumber, ver: API_VERSION_NUMBER };\n    const { meta, text } = (await getJson('/page', queryParams)) as PageApiResponse;\n\n    if (!meta && !text) {\n        throw new Error(`Book ${bookId}, page ${pageNumber} not found`);\n    }\n\n    return { meta: JSON.parse(meta) as PageMetadata, text };\n};\n\n/**\n * Searches for books or content using a query string.\n *\n * @param query - The search query string.\n * @param options - Optional search options, such as category or sort field.\n * @returns A promise that resolves to the search results.\n */\nexport const search = async (\n    query: string,\n    { category, sortField, ...options }: SearchOptions = {},\n): Promise<SearchResults> => {\n    const queryParams: SearchApiQueryParameters = {\n        ...options,\n        ...(category && { cat_id: category }),\n        ...(sortField && { sort: sortField }),\n        q: query,\n        ver: API_VERSION_NUMBER,\n    };\n    const { count, data } = (await getJson('/search', queryParams)) as SearchApiResponse;\n\n    return { count, data: data.map((r) => ({ ...r, meta: JSON.parse(r.meta) })) };\n};\n","export type BookQueryParams = {\n    /**\n     * ID of the book to fetch.\n     */\n    id: number;\n\n    /**\n     * Include additional data such as indexes. Optional parameter.\n     * Possible values: 'indexes', 'info', etc.\n     */\n    include?: string;\n\n    /**\n     * Version of the data format. Optional parameter.\n     */\n    ver?: number;\n};\n\n// Metadata of the book\nexport type BookMeta = {\n    /**\n     * ID of the author.\n     */\n    author_id: number;\n\n    /**\n     * Page where author details start.\n     */\n    author_page_start: number;\n\n    /**\n     * Category ID that the book belongs to.\n     */\n    cat_id: number;\n\n    /**\n     * The date when the book metadata was built, represented as a Unix timestamp.\n     */\n    date_built: number;\n\n    /**\n     * Unique identifier for the book.\n     */\n    id: number;\n\n    /**\n     * Short information about the book.\n     */\n    info: string;\n\n    /**\n     * Additional detailed information about the book (may be empty).\n     */\n    info_long: string;\n\n    /**\n     * Name of the book.\n     */\n    name: string;\n\n    /**\n     * Indicates the number of times the book has been printed.\n     */\n    printed: number;\n\n    /**\n     * Type of the book (e.g., 5 represents a specific category or classification).\n     */\n    type: number;\n\n    /**\n     * Version information of the book.\n     */\n    version: string;\n};\n\n// Definition for each heading in the index\nexport type BookHeading = {\n    /**\n     * Level of the heading (e.g., 1 for major sections, 3 for smaller subsections).\n     */\n    level: number;\n\n    /**\n     * Page number where this heading starts.\n     */\n    page: number;\n\n    /**\n     * Title of the heading.\n     */\n    title: string;\n};\n\n// Indexes that exist in the book\nexport type BookIndexes = {\n    /**\n     * Headings present within the book.\n     */\n    headings: BookHeading[];\n\n    /**\n     * Additional non-author content (e.g., prefaces, intros). May be empty.\n     */\n    non_author: any[];\n\n    /**\n     * Maps each page to the headings that begin on it.\n     */\n    page_headings: Record<number, number[]>;\n\n    /**\n     * Maps pages to their corresponding volume and page number.\n     */\n    page_map: string[];\n\n    /**\n     * Mapping from volume and print page to actual page number.\n     */\n    print_pg_to_pg: Record<string, number>;\n\n    /**\n     * Boundaries for each volume, specified as starting and ending page.\n     */\n    volume_bounds: Record<string, [number, number]>;\n\n    /**\n     * Volumes available in the book.\n     */\n    volumes: string[];\n};\n\nexport type BookApiResponse = {\n    /**\n     * Indexes of the book.\n     */\n    indexes: BookIndexes;\n\n    /**\n     * Metadata information about the book.\n     */\n    meta: BookMeta;\n};\n\nexport enum Includes {\n    Indexes = 'indexes',\n}\n\nexport type BookApiQueryParameters = {\n    id: number;\n    include?: Includes;\n    ver: number;\n};\n","import wretch, { Wretch } from 'wretch';\nimport QueryStringAddon from 'wretch/addons/queryString';\n\nconst baseApi = wretch('https://api.turath.io').addon(QueryStringAddon);\nconst fileApi: Wretch = wretch('https://files.turath.io/books');\n\ntype JsonResponse = Record<string, any>;\n\nexport const getFileJson = async (path: string): Promise<JsonResponse> => {\n    return fileApi.url(path).get().json();\n};\n\nexport const getJson = async (path: string, queryParams: JsonResponse = {}): Promise<JsonResponse> => {\n    return baseApi.url(path).query(queryParams).get().json();\n};\n","export type AuthorApiResponse = {\n    info: string;\n};\n\nexport type AuthorApiQueryParameters = {\n    id: number;\n    ver: number;\n};\n","// Meta information about a book\ntype BookMeta = {\n    author_id: number; // ID of the author\n    cat_id: number; // Category ID for classification\n    date_built: number; // Unix timestamp for when the data was built\n    details: string; // Details about the book, including author and edition information\n    has_pdf: boolean; // Flag indicating if a PDF is available\n    id: number; // Unique identifier for the book\n    name: string; // Name of the book\n    size: number; // Size of the book in bytes (presumably for PDF)\n};\n\n// Index information about the book, including volumes and PDF mappings\ntype BookIndexes = {\n    hadiths: Record<string, number>; // Mapping of hadith ID to the corresponding number within a volume\n    headings: Heading[]; // List of headings in the book\n    pdf_base: string; // Base path or name used for locating PDFs\n    pdfs: Record<string, string>; // Mapping of volume name to corresponding PDF file name\n    volumes: string[]; // List of volume names, e.g., ['المقدمة', '1', '2']\n};\n\n// A heading within the book, which includes a title, level, and page number\ntype Heading = {\n    level: number; // Level of the heading (e.g., 1 for main heading, 2 for subheading)\n    page: number; // Page number where the heading appears\n    title: string; // Title of the heading\n};\n\n// Generated index information, providing page mappings and volume boundaries\ntype GeneratedIndexes = {\n    hadith_max: string; // Maximum number of hadiths found in the book\n    hadith_pages: Record<string, string>; // Mapping of hadith number to page\n    page_headings: Record<number, number[]>; // Mapping of page number to a list of heading indices\n    page_map: (null | string)[]; // Array mapping logical page to print page reference\n    print_pg_to_pg: Record<string, number>; // Mapping from print pages to logical pages\n    volume_bounds: Record<string, [number, number]>; // Boundaries for each volume in terms of page numbers\n};\n\n// Represents an individual page within the book\ntype BookPage = {\n    page?: number; // Page number or identifier within the volume\n    text: string; // Text content of the page\n    vol?: string; // Volume identifier the page belongs to\n};\n\n// Main structure representing the complete book information\nexport type BookFileApiResponse = {\n    indexes: BookIndexes; // Indexes for navigating the book\n    indexes_generated: GeneratedIndexes; // Additional generated index information\n    meta: BookMeta; // Metadata about the book\n    pages: BookPage[]; // List of pages in the book\n};\n","import { PageApiResponse } from './api/page';\nimport { SearchResult as ApiSearchResult } from './api/search';\n\nexport type PageMetadata = {\n    author_name: string;\n    book_name: string;\n    headings?: string[];\n    page: number;\n    page_id: number;\n    vol: string;\n};\n\nexport type PageResult = {\n    meta: PageMetadata;\n} & Omit<PageApiResponse, 'meta'>;\n\nexport enum SortField {\n    PageId = 'page_id',\n}\n\nexport type SearchOptions = {\n    author?: number;\n    book?: number;\n    category?: number;\n    page?: number;\n    precision?: number;\n    sortField?: SortField;\n};\n\nexport type SearchResult = {\n    meta: PageMetadata;\n} & Omit<ApiSearchResult, 'meta'>;\n\nexport type SearchResults = {\n    count: number;\n    data: SearchResult[];\n};\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}