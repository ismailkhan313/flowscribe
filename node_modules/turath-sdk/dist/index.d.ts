type PageApiResponse = {
    meta: string;
    text: string;
};
type _SearchResult1 = {
    author_id: number;
    book_id: number;
    cat_id: number;
    meta: string;
    snip: string;
    text: string;
};
export type PageMetadata = {
    author_name: string;
    book_name: string;
    headings?: string[];
    page: number;
    page_id: number;
    vol: string;
};
export type PageResult = {
    meta: PageMetadata;
} & Omit<PageApiResponse, 'meta'>;
export enum SortField {
    PageId = "page_id"
}
export type SearchOptions = {
    author?: number;
    book?: number;
    category?: number;
    page?: number;
    precision?: number;
    sortField?: SortField;
};
export type SearchResult = {
    meta: PageMetadata;
} & Omit<_SearchResult1, 'meta'>;
export type SearchResults = {
    count: number;
    data: SearchResult[];
};
export type AuthorApiResponse = {
    info: string;
};
export type AuthorApiQueryParameters = {
    id: number;
    ver: number;
};
type BookMeta = {
    /**
     * ID of the author.
     */
    author_id: number;
    /**
     * Page where author details start.
     */
    author_page_start: number;
    /**
     * Category ID that the book belongs to.
     */
    cat_id: number;
    /**
     * The date when the book metadata was built, represented as a Unix timestamp.
     */
    date_built: number;
    /**
     * Unique identifier for the book.
     */
    id: number;
    /**
     * Short information about the book.
     */
    info: string;
    /**
     * Additional detailed information about the book (may be empty).
     */
    info_long: string;
    /**
     * Name of the book.
     */
    name: string;
    /**
     * Indicates the number of times the book has been printed.
     */
    printed: number;
    /**
     * Type of the book (e.g., 5 represents a specific category or classification).
     */
    type: number;
    /**
     * Version information of the book.
     */
    version: string;
};
type BookHeading = {
    /**
     * Level of the heading (e.g., 1 for major sections, 3 for smaller subsections).
     */
    level: number;
    /**
     * Page number where this heading starts.
     */
    page: number;
    /**
     * Title of the heading.
     */
    title: string;
};
type BookIndexes = {
    /**
     * Headings present within the book.
     */
    headings: BookHeading[];
    /**
     * Additional non-author content (e.g., prefaces, intros). May be empty.
     */
    non_author: any[];
    /**
     * Maps each page to the headings that begin on it.
     */
    page_headings: Record<number, number[]>;
    /**
     * Maps pages to their corresponding volume and page number.
     */
    page_map: string[];
    /**
     * Mapping from volume and print page to actual page number.
     */
    print_pg_to_pg: Record<string, number>;
    /**
     * Boundaries for each volume, specified as starting and ending page.
     */
    volume_bounds: Record<string, [number, number]>;
    /**
     * Volumes available in the book.
     */
    volumes: string[];
};
type BookApiResponse = {
    /**
     * Indexes of the book.
     */
    indexes: BookIndexes;
    /**
     * Metadata information about the book.
     */
    meta: BookMeta;
};
type _BookMeta1 = {
    author_id: number;
    cat_id: number;
    date_built: number;
    details: string;
    has_pdf: boolean;
    id: number;
    name: string;
    size: number;
};
type _BookIndexes1 = {
    hadiths: Record<string, number>;
    headings: Heading[];
    pdf_base: string;
    pdfs: Record<string, string>;
    volumes: string[];
};
type Heading = {
    level: number;
    page: number;
    title: string;
};
type GeneratedIndexes = {
    hadith_max: string;
    hadith_pages: Record<string, string>;
    page_headings: Record<number, number[]>;
    page_map: (null | string)[];
    print_pg_to_pg: Record<string, number>;
    volume_bounds: Record<string, [number, number]>;
};
type BookPage = {
    page?: number;
    text: string;
    vol?: string;
};
export type BookFileApiResponse = {
    indexes: _BookIndexes1;
    indexes_generated: GeneratedIndexes;
    meta: _BookMeta1;
    pages: BookPage[];
};
/**
 * Fetches author information by ID.
 *
 * @param id - The unique identifier of the author to retrieve.
 * @returns A promise that resolves to the author information.
 * @throws Will throw an error if the author is not found.
 */
export const getAuthor: (id: number) => Promise<AuthorApiResponse>;
/**
 * Fetches the book contents by ID.
 *
 * @param id - The unique identifier of the book to retrieve.
 * @returns A promise that resolves to the book file information.
 * @throws Will throw an error if the book file is not found.
 */
export const getBookFile: (id: number) => Promise<BookFileApiResponse>;
/**
 * Fetches the book information by ID.
 *
 * @param id - The unique identifier of the book to retrieve.
 * @returns A promise that resolves to the book information including indexes.
 */
export const getBookInfo: (id: number) => Promise<BookApiResponse>;
/**
 * Fetches a specific page from a book by book ID and page number.
 *
 * @param bookId - The unique identifier of the book.
 * @param pageNumber - The page number to retrieve.
 * @returns A promise that resolves to the page metadata and text.
 * @throws Will throw an error if the page is not found.
 */
export const getPage: (bookId: number, pageNumber: number) => Promise<PageResult>;
/**
 * Searches for books or content using a query string.
 *
 * @param query - The search query string.
 * @param options - Optional search options, such as category or sort field.
 * @returns A promise that resolves to the search results.
 */
export const search: (query: string, { category, sortField, ...options }?: SearchOptions) => Promise<SearchResults>;

//# sourceMappingURL=index.d.ts.map
